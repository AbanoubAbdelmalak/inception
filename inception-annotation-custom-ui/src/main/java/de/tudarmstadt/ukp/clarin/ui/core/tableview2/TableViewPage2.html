<!--
  Licensed to the Technische Universität Darmstadt under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The Technische Universität Darmstadt 
  licenses this file to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.
   
  http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<html xmlns:wicket="http://wicket.apache.org">
  <head>
    <wicket:head>
 	    <style>
        /*Temporary size for the grid, until we get to know how to change it with wicket*/
 	      .grid {
  		      width: 1600px;
  		      height: 720px;
  		  }

 	    </style>
    </wicket:head>

  </head>
  <body>
    <wicket:extend>
      <label wicket:id="detailForm" >DETFORM</label>
        <!-- Angularjs module -->
        <div ng-app="app">
          <!-- module controller -->
          <div ng-controller="MainCtrl">
            <!-- Grid -->
            <div ui-grid="gridOptions" ui-grid-cellNav ui-grid-pinning ui-grid-edit ui-grid-infinite-scroll class="grid"></div>
          </div>
        </div>
      <!-- necessary scripts for ui-grid and angularjs -->
      <script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.6.7/angular.js"></script>
      <script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.6.7/angular-touch.js"></script>
      <script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.6.7/angular-animate.js"></script>
      <script src="http://ui-grid.info/docs/grunt-scripts/csv.js"></script>
      <script src="http://ui-grid.info/docs/grunt-scripts/pdfmake.js"></script>
      <script src="http://ui-grid.info/docs/grunt-scripts/vfs_fonts.js"></script>
      <script src="http://ui-grid.info/docs/grunt-scripts/lodash.min.js"></script>
      <script src="http://ui-grid.info/docs/grunt-scripts/jszip.min.js"></script>
      <script src="http://ui-grid.info/docs/grunt-scripts/excel-builder.dist.js"></script>
      <script src="http://ui-grid.info/release/ui-grid.js"></script>
      <link rel="stylesheet" href="http://ui-grid.info/release/ui-grid.css" type="text/css">
      <!-- Start of the code -->
      <script>

      /**
      Function for parsing of the url for API calls
      */
      function findGetParameter(parameterName) {
        var result = null,
            tmp = [];
        location.search
            .substr(1)
            .split("&")
            .forEach(function (item) {
              tmp = item.split("=");
              if (tmp[0] === parameterName) result = decodeURIComponent(tmp[1]);
            });
        return result;
      }

      //AngularJs module with necessary ng and ui-grid arguments
      var app = angular.module('app', ['ngTouch', 'ui.grid', 'ui.grid.cellNav','ui.grid.edit', 'ui.grid.pinning','ui.grid.infiniteScroll']);
      //Controller for the module "app"
      app.controller('MainCtrl', ['$scope', '$http', '$log', function ($scope, $http, $log) {

    	// Parse base url
      	$scope.baseUrl = window.location.pathname.substring(0, window.location.pathname.indexOf("/",2));

    	//Document Id
      	  $scope.myDocId = findGetParameter("docId");
          //Project Id
      	  $scope.myProjId = findGetParameter("projId");
          //Counter for the beginning of the token list
          $scope.dataBegin = 0;
          //Counter for the end of the token list
          $scope.dataEnd = 100;
          //array for tokens
          $scope.tokens = [];
          //array for annotations
          $scope.annotations = [];
          //last loaded annotation index
          $scope.lastAnno = 0

        //grid options for ui-grid
        $scope.gridOptions = {
          infiniteScrollDown: true,
          enableSorting : false,
    	    modifierKeysToMultiSelectCells: true,
          keyDownOverrides: [ { keyCode: 39, ctrlKey: true }],
          showGridFooter: true,
          enableGridMenu: true,
          enableColumnMenus: false
        };

        /**
        @author Micha Tim Dippell
        @param index Index of the current token, @param annoType Annotation Layer Name as String, @param response the list of tokens returned from the server
        @return Annotation Value for given index and Annotation Layer
        */
        function getAnnotationValue(index, annoType, response){
            //find the layer corresponding to the name given in annoType
           var lay= $scope.layers.find(function(element){
               return element.uiName==annoType
           })
           //find an annotation matching the current token and the found layer
           var ann= $scope.annotations.find(function(element){
               return element.coveredTokens[0]==response[index].tokenId&&lay.layerId==element.layerId
           })
           //check if such an annotation was found
           if (typeof ann=='undefined'){
               return ''
           }
               else{
               //check if the found annotation has an allocated feature value
               if(ann.features[0].value==null){
                   return 'null'
               }
               //return the value
               else{
                   return ann.features[0].value
               }
           }
       }


	   	 /**
	      	Returns the uiName for a given layerId
	      */
	      function getUiName(layerId){
	      	uiName = $scope.layers.find(function (layer) {
	      		return layer.layerId == layerId;
	      	}).uiName;
	      	return (typeof uiName)=="undefined"?null:uiName;
	        }

	   	 /*
	   	 	Returns coveredText of the token with the given token id
	   	 */
	     function getCoveredTokens(tokenId) {
	   	 	found = $scope.tokens.find(function (tok) {
	   	 			return tok.tokenId == tokenId;
	   	 		}).coveredText;
	   	 		return (typeof found)=="undefined"?null:found;
	   	 }

      
      /**
      	function for getting the next data set for infinite scrolling
      	@author Sebastian Ochs
      */
      $scope.getDataDown = function(){
      	//GET-Request for documents for the current project
          	$http.get($scope.baseUrl+"/api/ruita/projects/"+$scope.myProjId+"/documents/").then(function(response){
          	    console.log("API get documents");
          		console.log(response);
          	    	
          		//Search for the tokenCount for the current document
          	    for (i = 0; i < response.data.content.length; i ++){
          	       if($scope.myDocId == response.data.content[i].id){
          	       	//maxTokenCount needed to limit dataEnd
          	            $scope.maxTokenCount = response.data.content[i].tokenCount;
          	          }
          	        }         	
          
      	

        //API call to get all defined layers from the project
    	  $http.get($scope.baseUrl+"/api/ruita/projects/"+$scope.myProjId+"/layers")
  		    .then(function (response) {
  		    	console.log("API get layers");
  				console.log(response);

  			  $scope.layers = response.data;

  			  //API call to get tokens from the opened document from a project
    	    $http.get($scope.baseUrl+"/api/ruita/projects/"+$scope.myProjId+"/documents/"+$scope.myDocId+"/tokens?from="+$scope.dataBegin+"&to="+$scope.dataEnd)
  	        .then(function (response) {
  	        	console.log("API get tokens");
  	  			console.log(response);

  		       $scope.tokens = $scope.tokens.concat(response.data);

  		   		//check, if dataEnd succeeded maxTokenCount, if yes, set dataEnd to maxTokenCount
  		        if($scope.maxTokenCount < $scope.dataEnd){
  		            $scope.dataEnd = $scope.maxTokenCount;
  		          }
  		          //this is just for safety, as this should never occur
  		          if($scope.maxTokenCount <= $scope.dataBegin){
  		            console.log("No more Tokens");
  		            return;
  		          }

  		       //API call to get annotations from the document
  		  	     $http.get($scope.baseUrl+"/api/ruita/projects/"+$scope.myProjId+"/documents/"+$scope.myDocId+"/annotations?textIndexFrom="+$scope.tokens[$scope.dataBegin].begin+"&textIndexTo="+$scope.tokens[$scope.dataEnd -1].end)
                 //function to build a JSON file for ui-grid to represent the tokens and their annotations
  	             .then(function (response) {
  	            	console.log("API get annotations");
  	  	  			console.log(response);

                    $scope.annotations = $scope.annotations.concat(response.data);

                       //for-loop to build the objects that are used to display the data
  		               for(i=$scope.lastAnno;i<$scope.annotations.length;i++){
  			                  var obj = {
                            //['begin']: $scope.tokens[i].begin,
                            //['end']: $scope.tokens[i].end,
                            ['Annotation ID']: $scope.annotations[i].annotationId,
                            ['Annotation Type']: getUiName($scope.annotations[i].layerId),
                            ['Covered Tokens']: "",
                            ['Features']: ""
                            }
  			                  for(j=0;j<$scope.annotations[i].coveredTokens.length;j++){
  			                	covTok = getCoveredTokens($scope.annotations[i].coveredTokens[j])
  			                	if(covTok != "undefined"){
  			                	  obj['Covered Tokens'] += covTok+" "
  			                	}
  			                  }
  			                  for(l=0;l<$scope.annotations[i].features.length;l++){
  			                	layerFeatures = $scope.layers.find(function (layer) {
  			      	      			return layer.layerId == $scope.annotations[i].layerId;
  			      	      			}).features;
  			                	if(typeof(layerFeatures!="undefined")){
  			                		layerFeature = layerFeatures.find(function (feature){
  			                			return feature.id==$scope.annotations[i].features[l].id
  			                		})
  			                		obj['Features']+="| "+layerFeature.uiName+" : "+$scope.annotations[i].features[l].value+" "
  			                	}
  			                  }

  			              //push the object into the grid data
                          $scope.gridOptions.data.push(obj);
                     }

                     //Update parameters for the next data set
                     $scope.dataBegin = $scope.dataEnd;
                     $scope.dataEnd = $scope.dataEnd + 100;
                     $scope.lastAnno = $scope.annotations.length;
                   //Create the columns to display data, token data may not be edited and can't be hidden
                   $scope.gridOptions.columnDefs = [
                     //{ name: 'begin', enableCellEdit : false, enableHiding : false},
                     //{ name: 'end', enableCellEdit : false, enableHiding : false},
                     { name: 'Annotation ID', enableCellEdit : false, enableHiding : false},
                     { name: 'Annotation Type', enableCellEdit : false, enableHiding : false},
                     { name: 'Covered Tokens', enableCellEdit : false, enableHiding : false},
                     { name: 'Features', enableCellEdit : false, enableHiding : false}
                   ];

                   //notify gridAPI that the data has been built and loaded
                   $scope.gridApi.infiniteScroll.dataLoaded();
                 });
  	           });
            });
          });
        }

      	//execute getDataDown just once
        $scope.getDataDown();

      	//Following functions up until gridOptions.onRegisterApi are for focusing a grid cell
        $scope.info = {};

      	$scope.currentFocused = "";

      	// Determines the current focus
        $scope.getCurrentFocus = function(){
          var rowCol = $scope.gridApi.cellNav.getFocusedCell();
          if(rowCol !== null) {
              $scope.currentFocused = 'Row Id:' + rowCol.row.entity.id + ' col:' + rowCol.col.colDef.name;
          }
        };

        // Determines the current selection
        $scope.getCurrentSelection = function() {
          var values = [];
          var currentSelection = $scope.gridApi.cellNav.getCurrentSelection();
          for (var i = 0; i < currentSelection.length; i++) {
            values.push(currentSelection[i].row.entity[currentSelection[i].col.name])
          }
          $scope.printSelection = values.toString();
        };

        // Function for Scrolling
        $scope.scrollTo = function( rowIndex, colIndex ) {
          $scope.gridApi.core.scrollTo( $scope.gridOptions.data[rowIndex], $scope.gridOptions.columnDefs[colIndex]);
        };

        // Scrolls to a focused index
        $scope.scrollToFocus = function( rowIndex, colIndex ) {
          $scope.gridApi.cellNav.scrollToFocus( $scope.gridOptions.data[rowIndex], $scope.gridOptions.columnDefs[colIndex]);
        };

		// grid API. Defines inner functions.
        $scope.gridOptions.onRegisterApi = function(gridApi){
           $scope.gridApi = gridApi;
           $scope.msg = "";

           //log entry for navigation
           gridApi.cellNav.on.navigate($scope,function(newRowCol, oldRowCol){
                 // var rowCol = {row: newRowCol.row.index, col:newRowCol.col.colDef.name};
                 // var msg = 'New RowCol is ' + angular.toJson(rowCol);
                 // if(oldRowCol){
                 //    rowCol = {row: oldRowCol.row.index, col:oldRowCol.col.colDef.name};
                 //    msg += ' Old RowCol is ' + angular.toJson(rowCol);
                 // }
                  $log.log('navigation event');
                });

           //hotkey strg+arrowLeft
           gridApi.cellNav.on.viewPortKeyDown($scope,function(event, newRowCol){
                    var row = newRowCol.row;
                    var col = newRowCol.col
                    if (event.keyCode === 39) {
                        $scope.gridApi.cellNav.scrollToFocus(row.entity, $scope.gridApi.grid.columns[$scope.gridApi.grid.columns.length - 1]);
                    }
                });

           //notify navigation, when a column visibility has changed
           gridApi.core.on.columnVisibilityChanged( $scope, function( changedColumn ){
                $scope.columnChanged = { name: changedColumn.colDef.name, visible: changedColumn.colDef.visible };
              });

           //infiniteScrolling
           gridApi.infiniteScroll.on.needLoadMoreData($scope, $scope.getDataDown);

           /*
           	Edit events of grid UI
           */
           gridApi.edit.on.afterCellEdit($scope,function(rowEntity, colDef, newValue, oldValue){
              $scope.msg.lastCellEdited = 'edited row id:' + rowEntity.id + ' Column:' + colDef.name + ' newValue:' + newValue + ' oldValue:' + oldValue ;

              /**
           	  	function to return the layer id for an annotation Type
              */
              function getLayerId(annoType){
                for (i = 0; i < $scope.layers.length; i++){
                  if ($scope.layers[i].uiName == annoType){
                    console.log("layerId: " + $scope.layers[i].layerId);
                    return $scope.layers[i].layerId;
                  }
                }
                console.error("A layer with the type " + annoType + " is not defined for this project");
              }

              /**
              	function to return the feature id for a given layer id
              */
              function getFeatureIdOfLayer(layerId){
                for (i = 0; i < $scope.layers.length; i++){
                  if ($scope.layers[i].layerId == layerId){
                    console.log("featureId: " + $scope.layers[i].features[0].id);
                    return $scope.layers[i].features[0].id;

                  }
                }
                console.error("A layer with the id " + layerId + " is not defined for this project")
              }

              /**
              	function to return the annotationId for a given annotation begin and layer id
              */
              function getAnnotationId(begin, layerId){
                for (i = 0; i < $scope.annotations.length; i++){
                  if ($scope.annotations[i].begin == begin){
                    if ($scope.annotations[i].layerId == layerId){
                      console.log("annotationId: " + $scope.annotations[i].annotationId);
                      return $scope.annotations[i].annotationId;
                    }
                  }
                }
                console.error("There is no annotation with the id " + layerId + " at " + begin);
              }
            });
        };

      }]);

      </script>
	 	</wicket:extend>
  </body>
</html>
