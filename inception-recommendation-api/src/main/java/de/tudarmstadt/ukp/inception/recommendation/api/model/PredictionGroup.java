/*
 * Copyright 2018
 * Ubiquitous Knowledge Processing (UKP) Lab
 * Technische Universit√§t Darmstadt
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.tudarmstadt.ukp.inception.recommendation.api.model;

import static java.util.Arrays.asList;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonMap;
import static java.util.Collections.sort;
import static java.util.Collections.unmodifiableList;
import static java.util.Collections.unmodifiableMap;
import static java.util.Comparator.comparing;
import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.toList;
import static org.apache.commons.collections4.IteratorUtils.unmodifiableIterator;

import java.io.Serializable;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Stream;

import org.apache.commons.lang3.Validate;

/**
 * Group of alternative predictions generated by one or more recommenders. The group maintains an
 * order of the alternative predictions, by default using the confidence score.
 */
public class PredictionGroup
    extends AbstractCollection<AnnotationObject>
    implements Serializable
{
    private static final long serialVersionUID = 8729617486073480240L;
    
    private final List<AnnotationObject> predictions;
    private boolean sorted = true;

    public PredictionGroup()
    {
        predictions = new ArrayList<>();
    }
    
    public PredictionGroup(AnnotationObject... aItems)
    {
        predictions = new ArrayList<>(asList(aItems));
        sorted = predictions.size() < 1;
    }
    
    public AnnotationObject get(int aIndex)
    {
        return predictions.get(aIndex);
    }
    
    private void ensureSortedState()
    {
        // To the outside, the group should appear to be sorted.
        if (!sorted) {
            sort(predictions, comparing(AnnotationObject::getConfidence).reversed());
            sorted = true;
        }
    }
    
    @Override
    public Stream<AnnotationObject> stream()
    {
        ensureSortedState();
        return predictions.stream();
    }
    
    /**
     * Get the deltas of all candidates. The deltas are calculated separately for each recommender
     * if the group contains recommendations from multiple recommenders. That is necessary because
     * the confidence scores of different recommenders are not necessarily on the same scale.
     * Additionally, only predictions that are {@link AnnotationObject#isVisible() visible} are
     * taken into consideration.
     */
    public Map<Long, List<Delta>> getAllDeltas()
    {
        if (isEmpty()) {
            return emptyMap();
        }
        else if (size() == 1) {
            AnnotationObject top = get(0);
            return singletonMap(top.getRecommenderId(), asList(new Delta(top)));
        }
        else {
            // Group the candidates by recommender because the confidence scores cannot be compared
            // across recommenders
            Map<Long, List<AnnotationObject>> predictionsByRecommenders = stream()
                    .collect(groupingBy(AnnotationObject::getRecommenderId));

            Map<Long, List<Delta>> result = new HashMap<>();
            for (Entry<Long, List<AnnotationObject>> e : predictionsByRecommenders.entrySet()) {
                long recommenderId = e.getKey();
                // We consider only candidates that are visible
                List<AnnotationObject> candidates = e.getValue().stream()
                        .filter(AnnotationObject::isVisible).collect(toList());
                List<Delta> deltas = new ArrayList<>();
                
                Iterator<AnnotationObject> i = candidates.iterator();
                AnnotationObject first = i.next();
                while (i.hasNext()) {
                    AnnotationObject second = i.next();
                    deltas.add(new Delta(first, second));
                    first = second;
                }
                deltas.add(new Delta(first));
                
                result.put(recommenderId, unmodifiableList(deltas));
            }
            
            return unmodifiableMap(result);
        }
    }

    /**
     * Get the top delta per recommender. The deltas are calculated separately for each recommender
     * if the group contains recommendations from multiple recommenders. That is necessary because
     * the confidence scores of different recommenders are not necessarily on the same scale.
     * Additionally, only predictions that are {@link AnnotationObject#isVisible() visible} are
     * taken into consideration.
     */
    public Map<Long, Delta> getTopDeltas()
    {
        if (isEmpty()) {
            return emptyMap();
        }
        else if (size() == 1) {
            AnnotationObject top = get(0);
            return singletonMap(top.getRecommenderId(), new Delta(top));
        }
        else {
            // Group the candidates by recommender because the confidence scores cannot be compared
            // across recommenders - note that the grouped lists are still sorted as the
            // "predictions" field is sorted.
            Map<Long, List<AnnotationObject>> predictionsByRecommenders = stream()
                    .collect(groupingBy(AnnotationObject::getRecommenderId));

            Map<Long, Delta> result = new HashMap<>();
            for (Entry<Long, List<AnnotationObject>> e : predictionsByRecommenders.entrySet()) {
                long recommenderId = e.getKey();
                // We consider only candidates that are visible - note that the filtered list is
                // still sorted
                List<AnnotationObject> candidates = e.getValue().stream()
                        .filter(AnnotationObject::isVisible)
                        .collect(toList());
                
                if (candidates.isEmpty()) {
                    // If a recommender has no visible candidates, we skip it - nothing to do here
                }
                else if (candidates.size() == 1) {
                    // If there is only one visible candidate, grab it to create the delta
                    result.put(recommenderId, new Delta(candidates.get(0)));
                }
                else {
                    // Expoiting the fact that the filtered candidates are still sorted, we just
                    // grab the first and second one to construct the delta
                    result.put(recommenderId, new Delta(candidates.get(0), candidates.get(1)));
                }
            }
            
            return unmodifiableMap(result);
        }
    }

    @Override
    public boolean add(AnnotationObject aPrediction)
    {
        // When we add the second element to the group, then it is probably no longer sorted
        if (!isEmpty()) {
            sorted = false;
        }
        return predictions.add(aPrediction);
    }

    @Override
    public Iterator<AnnotationObject> iterator()
    {
        ensureSortedState();
        // Avoid changes to the group via the iterator since that might interfere with our sorting
        return unmodifiableIterator(predictions.iterator());
    }

    @Override
    public int size()
    {
        return predictions.size();
    }

    public static PredictionGroupCollector collector()
    {
        return new PredictionGroupCollector();
    }

    public static class Delta
        implements Serializable
    {
        private static final long serialVersionUID = -4892325166786170047L;
        
        private final double delta;
        private final AnnotationObject first;
        private final AnnotationObject second;

        public Delta(AnnotationObject aFirst)
        {
            this(aFirst, null);
        }

        public Delta(AnnotationObject aFirst, AnnotationObject aSecond)
        {
            Validate.notNull(aFirst, "At least first item must be given to compute delta");

            first = aFirst;
            second = aSecond;

            if (second == null) {
                delta = Math.abs(aFirst.getConfidence());
            }
            else {
                delta = Math.abs(first.getConfidence() - second.getConfidence());
            }
        }

        public AnnotationObject getFirst()
        {
            return first;
        }

        public Optional<AnnotationObject> getSecond()
        {
            return Optional.ofNullable(second);
        }

        public double getDelta()
        {
            return delta;
        }
    }
    
    public static class PredictionGroupCollector
        implements Collector<AnnotationObject, PredictionGroup, PredictionGroup>
    {

        @Override
        public Supplier<PredictionGroup> supplier()
        {
            return PredictionGroup::new;
        }

        @Override
        public BiConsumer<PredictionGroup, AnnotationObject> accumulator()
        {
            return PredictionGroup::add;
        }

        @Override
        public BinaryOperator<PredictionGroup> combiner()
        {
            return (group1, group2) -> {
                group2.forEach(ao -> group1.add(ao));
                return group1;
            };
        }

        @Override
        public Function<PredictionGroup, PredictionGroup> finisher()
        {
            return Function.identity();
        }

        @Override
        public Set<Characteristics> characteristics()
        {
            return Collections.emptySet();
        }
    }
}
