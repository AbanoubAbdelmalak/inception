/*******************************************************************************
 * Copyright 2015
 * Ubiquitous Knowledge Processing (UKP) Lab and FG Language Technology
 * Technische Universit√§t Darmstadt
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

/*
 * JavaCC template file for parsing the WebAnno constraints language
 */
options
{
  IGNORE_CASE = true;
  JAVA_UNICODE_ESCAPE = true ;
}

PARSER_BEGIN(ConstraintsGrammar)
package de.tudarmstadt.ukp.clarin.webanno.constraints.grammar;

public class ConstraintsGrammar
{
}

PARSER_END(ConstraintsGrammar)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

SPECIAL_TOKEN :
{
  /* Only multi-line comments are currently supported */
  < MULTI_LINE_COMMENT :
    "/*" (~[ "*" ])* "*"
    (
      "*"
    |
      (
        ~[ "*", "/" ] (~[ "*" ])* "*"
      )
    )*
    "/" >
}

TOKEN :
{
  < IMPORT : "import" >
| < AS : "as" >
| < SEMICOLON : ";" >
| < IMPLIES : "->" >
| < EQUALS : "=" >
| < FLAG_IMPORTANT : "!" >
| < RRB : ")" >
| < LRB : "(" >
| < RCB : "}" >
| < LCB : "{" >
| < RSB : "]" >
| < LSB : "[" >
| < IDENTIFIER : <LETTER> (<LETTER> | <DIGIT>)* >
| < #LETTER : [ "a"-"z", "A"-"Z", "_" ] >
| < #DIGIT : [ "0"-"9" ] >
| < STRING_LITERAL : "\"" ("\\" ~[ ] | ~["\"", "\\"])* "\"" >
}

/*
 * ACTUAL GRAMMAR IMPLEMENTATION
 */
void CLParse() : {} {
  (CLImports())?
  (CLScopedDeclarations())+
  <EOF>
}

void CLScopedDeclarations() : {} {
  CLShortTypeName() <LCB> 
    (CLRules())* 
  <RCB>
}

void CLImports() : {} {
  (CLImportDeclaration())+
}

void CLRules() : {} {
  (CLRuleDeclaration())+
}

void CLImportDeclaration() : {} {
  <IMPORT> CLQualifiedTypeName() <AS> CLShortTypeName() <SEMICOLON>
}

void CLQualifiedTypeName() : {} {
  <IDENTIFIER> ("." <IDENTIFIER>)*
}

void CLShortTypeName() : {} {
  <IDENTIFIER>
}

void CLRuleDeclaration() : {} {
  CLConditions() <IMPLIES> CLRestrictions() <SEMICOLON>
}

void CLConditions() : {} {
  CLCondition() (LOOKAHEAD(2) "&" CLCondition())*
}

void CLCondition() : {} {
  CLPath() <EQUALS> CLConditionValue()
}

void CLConditionValue() : {} {
  <STRING_LITERAL>
}

void CLRestrictions() : {} {
  CLRestriction() (LOOKAHEAD(2) "|" CLRestriction())*
}

void CLRestriction() : {} {
  CLPath() <EQUALS> CLRestrictionValue() (CLFlagList())?
}

void CLRestrictionValue() : {} {
  <STRING_LITERAL>
}

void CLFlagList() : {} {
  <LRB> CLFlagImportant() <RRB>
}

void CLFlagImportant() : {} {
  <FLAG_IMPORTANT>
}

void CLPath() : {} {
  CLPathElement() ("." CLPathElement())*
}

void CLPathElement() : {} {
  (LOOKAHEAD(2) CLFunctionPathElement() | CLFeaturePathElement() | CLLayerPathElement())
}

void CLFeaturePathElement() : {} {
  <IDENTIFIER>
}

void CLLayerPathElement() : {} {
  "@" <IDENTIFIER>
}

void CLFunctionPathElement() : {} {
  <IDENTIFIER> CLArgumentList()
}

void CLArgumentList() : {} {
  <LRB><RRB>
}
